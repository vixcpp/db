#include <vix/db/mig/sql/MySqlGenerator.hpp>

#include <sstream>
#include <stdexcept>

namespace vix::db::mig::sql
{
  using namespace vix::db::schema;
  using namespace vix::db::mig::diff;

  static std::string q(const std::string &ident)
  {
    // MySQL identifier quote
    return "`" + ident + "`";
  }

  static std::string type_mysql(const Type &t)
  {
    switch (t.base)
    {
    case BaseType::Int:
      return "INT";
    case BaseType::BigInt:
      return "BIGINT";
    case BaseType::Double:
      return "DOUBLE";
    case BaseType::Bool:
      return "TINYINT(1)";
    case BaseType::Text:
      return "TEXT";
    case BaseType::DateTime:
      return "DATETIME";
    case BaseType::VarChar:
      if (!t.size)
        throw std::runtime_error("VARCHAR requires size");
      return "VARCHAR(" + std::to_string(*t.size) + ")";
    }
    return "TEXT";
  }

  static std::string column_mysql(const Column &c)
  {
    std::ostringstream o;
    o << q(c.name) << " " << type_mysql(c.type);

    if (!c.nullable)
      o << " NOT NULL";
    else
      o << " NULL";

    if (c.auto_increment)
      o << " AUTO_INCREMENT";

    if (c.def)
      o << " DEFAULT " << c.def->sql_literal;

    // PK & UNIQUE are best done in table-level constraints,
    // but for MVP we allow inline UNIQUE for single column.
    if (c.unique && !c.primary_key)
      o << " UNIQUE";

    return o.str();
  }

  static std::string create_table_mysql(const Table &t)
  {
    std::ostringstream o;
    o << "CREATE TABLE IF NOT EXISTS " << q(t.name) << " (\n";

    // columns
    for (size_t i = 0; i < t.columns.size(); ++i)
    {
      o << "  " << column_mysql(t.columns[i]);
      o << (i + 1 < t.columns.size() ? "," : "");
      o << "\n";
    }

    // primary key (single column MVP)
    for (const auto &c : t.columns)
    {
      if (c.primary_key)
      {
        o << ",  PRIMARY KEY (" << q(c.name) << ")\n";
        break;
      }
    }

    o << ") ENGINE=InnoDB;";
    return o.str();
  }

  static std::string drop_table_mysql(const Table &t)
  {
    return "DROP TABLE IF EXISTS " + q(t.name) + ";";
  }

  static std::string add_column_mysql(const std::string &table, const Column &c)
  {
    return "ALTER TABLE " + q(table) + " ADD COLUMN " + column_mysql(c) + ";";
  }

  static std::string drop_column_mysql(const std::string &table, const Column &c)
  {
    return "ALTER TABLE " + q(table) + " DROP COLUMN " + q(c.name) + ";";
  }

  static std::string create_index_mysql(const std::string &table, const Index &i)
  {
    std::ostringstream o;
    o << "CREATE ";
    if (i.unique)
      o << "UNIQUE ";
    o << "INDEX " << q(i.name) << " ON " << q(table) << " (";
    for (size_t k = 0; k < i.columns.size(); ++k)
    {
      o << q(i.columns[k]);
      if (k + 1 < i.columns.size())
        o << ",";
    }
    o << ");";
    return o.str();
  }

  static std::string drop_index_mysql(const std::string &table, const Index &i)
  {
    // MySQL: DROP INDEX idx ON table
    return "DROP INDEX " + q(i.name) + " ON " + q(table) + ";";
  }

  static void emit_up(std::ostringstream &o, const Op &op)
  {
    std::visit([&](auto &&x)
               {
      using T = std::decay_t<decltype(x)>;
      if constexpr (std::is_same_v<T, CreateTable>) o << create_table_mysql(x.table) << "\n";
      else if constexpr (std::is_same_v<T, DropTable>) o << drop_table_mysql(x.table) << "\n";
      else if constexpr (std::is_same_v<T, AddColumn>) o << add_column_mysql(x.table, x.column) << "\n";
      else if constexpr (std::is_same_v<T, DropColumn>) o << drop_column_mysql(x.table, x.column) << "\n";
      else if constexpr (std::is_same_v<T, CreateIndex>) o << create_index_mysql(x.table, x.index) << "\n";
      else if constexpr (std::is_same_v<T, DropIndex>) o << drop_index_mysql(x.table, x.index) << "\n"; }, op);
  }

  static void emit_down(std::ostringstream &o, const Op &op)
  {
    // Down is inverse operation
    std::visit([&](auto &&x)
               {
      using T = std::decay_t<decltype(x)>;
      if constexpr (std::is_same_v<T, CreateTable>) o << drop_table_mysql(x.table) << "\n";
      else if constexpr (std::is_same_v<T, DropTable>) o << create_table_mysql(x.table) << "\n";
      else if constexpr (std::is_same_v<T, AddColumn>) o << drop_column_mysql(x.table, x.column) << "\n";
      else if constexpr (std::is_same_v<T, DropColumn>) o << add_column_mysql(x.table, x.column) << "\n";
      else if constexpr (std::is_same_v<T, CreateIndex>) o << drop_index_mysql(x.table, x.index) << "\n";
      else if constexpr (std::is_same_v<T, DropIndex>) o << create_index_mysql(x.table, x.index) << "\n"; }, op);
  }

  std::string to_mysql_up(const std::vector<Op> &ops)
  {
    std::ostringstream o;
    o << "-- Generated by Vix ORM (MySQL)\n";
    for (const auto &op : ops)
      emit_up(o, op);
    return o.str();
  }

  std::string to_mysql_down(const std::vector<Op> &ops)
  {
    std::ostringstream o;
    o << "-- Generated by Vix ORM (MySQL) [DOWN]\n";
    // reverse order for down
    for (auto it = ops.rbegin(); it != ops.rend(); ++it)
      emit_down(o, *it);
    return o.str();
  }

} // namespace vix::db::mig::sql
